A session is a server side idea, which we then store in the database there and we would send the session

if we're having a single page application and then a server side API, these two ends are not as closely connected as they are in an application where the server side renders HTML code.

API is stateless, which means it's totally decoupled from the front end, it doesnt want ot remember the sessions 

The server is the only one who knows this private key, which in the end led to this exact token, and therefore the server is able to validate the token which is attached to an incoming request.

bcrypt allows to hash the secret keys/passwords (convering into encoded/non readable manner) for securitu reasons
it also allows to compare incoming key and stored hash key and returns the boolean value if its matching or not

jwt allows to store the private key in server and issues special key encoded tokens which can be sent to clients. It validates the incoming token from client, matches with secret key

token, which is generated by server is stored as cookie/ in local storage in the client or of browser. token is attached to the requests and is sent to the server.

Please note that try-catch can be used like asyncronous not in the callback. inside try block where we are calling the function you can await it

//hashing the password
try{
    let hashedPassword = await bcrypt.hash(password, 12)
}catch(error){
    console.log(error)
}
//comparing with the hashed password
try{
    let isValidPassword = await bcrypt.compare(password, stored.password)
}catch(error){
    console.log(error)
}

//jwt implementation

const jwt = require('jsonwebtoken')
//sigining
const token = jwt.sign({userId: req.body.userId, passkey: pss}, 'superSecretKey', {expiresIn: 2h})
//verifying the token
const token =  req.headers.authorization.split(" ")[1]
const decodedToken =  jwt.verify(token, 'yourSecretKey');
req.userData = {useId: decodedToken.userId}
next()

instead of calling this middleware for each and every route, we can call in the beginning of all the routes
router.use(checkAuth)

for adding extra security or validation for high security operations, extract user data from jwt verify middleware and compared it with the stored data.

managing tokens in front end

store userid and token in local storage
set take expiration time set in jwt and create new expiration time when login function is called, and store expiration time in localstorage too
incase of auto login, even when the old session is active, refresh it by extending at that time
verifying: if expiration time > token time
